new
  rl(`rho:registry:lookup`), RhoSpecCh,
  test_newline_escape, test_tab_escape, test_quote_escape,
  test_backslash_escape, test_unicode_escape, test_combined_escapes,
  test_no_escape_needed
in {
  rl!(`rho:id:zphjgsfy13h1k85isc8rtwtgt3t9zzt5pjd5ihykfmyapfc4wt3x5h`, *RhoSpecCh) |
  for(@(_, RhoSpec) <- RhoSpecCh) {
    @RhoSpec!("testSuite",
      [
        ("Newline escape sequences are unescaped correctly", *test_newline_escape),
        ("Tab escape sequences are unescaped correctly", *test_tab_escape),
        ("Quote escape sequences are unescaped correctly", *test_quote_escape),
        ("Backslash escape sequences are unescaped correctly", *test_backslash_escape),
        ("Combined escape sequences are unescaped correctly", *test_combined_escapes),
        ("Strings without escapes remain unchanged", *test_no_escape_needed)
      ])
  } |

  contract test_newline_escape(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("Hello\nWorld".toUtf8Bytes().bytesToHex()) |
      for (@msg <- ch) {
        rhoSpec!("assert", ("Hello\nWorld".toUtf8Bytes().bytesToHex(), "==", msg), "Newline escaped string unescaped correctly", *ackCh)
      }
    }
  } |

  contract test_tab_escape(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("Column1\tColumn2".toUtf8Bytes().bytesToHex()) |
      for (@msg <- ch) {
        rhoSpec!("assert", ("Column1\tColumn2".toUtf8Bytes().bytesToHex(), "==", msg), "Tab escaped string unescaped correctly", *ackCh)
      }
    }
  } |

  contract test_quote_escape(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("She said \"Hello\"".toUtf8Bytes().bytesToHex()) |
      for (@msg <- ch) {
        rhoSpec!("assert", ("She said \"Hello\"".toUtf8Bytes().bytesToHex(), "==", msg), "Quote escaped string unescaped correctly", *ackCh)
      }
    }
  } |

  contract test_backslash_escape(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("Path: C:\\Users\\Documents".toUtf8Bytes().bytesToHex()) |
      for (@msg <- ch) {
        rhoSpec!("assert", ("Path: C:\\Users\\Documents".toUtf8Bytes().bytesToHex(), "==", msg), "Backslash escaped string unescaped correctly", *ackCh)
      }
    }
  } |

  contract test_combined_escapes(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("Line1\nTab\tQuote\"Backslash\\End".toUtf8Bytes().bytesToHex()) |
      for (@msg <- ch) {
        rhoSpec!("assert", ("Line1\nTab\tQuote\"Backslash\\End".toUtf8Bytes().bytesToHex(), "==", msg), "Multiple escape sequences handled correctly", *ackCh)
      }
    }
  } |

  contract test_no_escape_needed(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("SimpleStringWithoutEscapes".toUtf8Bytes().bytesToHex()) |
      for (@msg <- ch) {
        rhoSpec!("assert", ("SimpleStringWithoutEscapes".toUtf8Bytes().bytesToHex(), "==", msg), "String without escapes passes through unchanged", *ackCh)
      }
    }
  }
}
